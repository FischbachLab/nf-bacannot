// User inputs multiple genomes

workflow bacannot_multiple_genomes_nf {
  take:
    input_tuple
  main:
  // First we need to parse and separate the values in (main -> fasta and prefix) and (additional -> files for methylation annotation)
  input_tuple.multiMap { it ->
    base: [ it[0], it[1] ]
    add:  [ it[0], it[2], it[3] ]
    prefix: it[0]
  }.set { prokka_input }

  // Then we can start with the first process, Prokka annotation

  // Prokka Annotation
  prokka(prokka_input.base)

  // MLST analysis
  mlst(prokka.out[3])

  // rRNA prediction
  barrnap(prokka.out[3])

  // Genome masking and removal of nucleotide sequences from prokka gff
  // masking_genome(prokka.out[3], prokka.out[1], parsed_input.prefix)

  // Computing GC content
  compute_gc(prokka.out[3])

  // User wants kofamscan?
  if (params.not_run_kofamscan == false) {
    kofamscan(prokka.out[4])
    kofamscan_output = kofamscan.out[1]
  } else { kofamscan_output = Channel.empty() }

  // User wants virulence search?
  if (params.not_run_virulence_search == false) {
    vfdb(prokka.out[5])
    vfdb_output = vfdb.out[0]
    victors(prokka.out[5])
    victors_output = victors.out[0]
  } else {
    vfdb_output    = Channel.empty()
    victors_output = Channel.empty()
  }

  // User wants resistance search?
  if (params.not_run_resistance_search == false) {
    amrfinder(prokka.out[4])
    amrfinder_output = amrfinder.out[0]
    rgi(prokka.out[4])
    rgi_output = rgi.out[3]
  } else {
    amrfinder_output = Channel.empty()
    rgi_output       = Channel.empty()
  }

  // User wants to use ICEberg db?
  if (params.not_run_iceberg_search == false) {
    iceberg(prokka.out[5])
    iceberg_output = iceberg.out[0]
  } else { iceberg_output = Channel.empty() }

  // User wants prophage search?
  if (params.not_run_prophage_search == false) {
    phast(prokka.out[5])
    phast_output       = phast.out[0]
    phigaro(prokka.out[3])
    phigaro_output     = phigaro.out[1]
    phigaro_output_txt = phigaro.out[0]
  } else {
    phast_output       = Channel.empty()
    phigaro_output     = Channel.empty()
    phigaro_output_txt = Channel.empty()
  }

  // Prediction of Genomic Islands
  find_GIs(prokka.out[2])

  // Merge all annotations with the same Prefix value in a single Channel
  annotations_files = prokka.out[3].join(prokka.out[1])
                                   .join(mlst.out[0])
                                   .join(barrnap.out[0])
                                   .join(compute_gc.out[0])
                                   .join(kofamscan_output, remainder: true)
                                   .join(vfdb_output, remainder: true)
                                   .join(victors_output, remainder: true)
                                   .join(amrfinder_output, remainder: true)
                                   .join(rgi_output, remainder: true)
                                   .join(iceberg_output, remainder: true)
                                   .join(phast_output, remainder: true)
                                   .join(phigaro_output, remainder: true)
                                   .join(find_GIs.out[0])

  // Contatenation of annotations in a single GFF file
  update_gff(annotations_files)

  // Create MongoDB Collection
  mongoDB(update_gff.out[0])

  // Convert GFF file to GBK file
  gff2gbk(update_gff.out[0].join(prokka.out[3]))

  // User wants to merge the final gff file?
  if (params.bedtools_merge_distance != '') {
    gff_merge(update_gff.out[0])
  }

  // Grab all input files with new genome/contig names for methylation call
  methylation_input = prokka.out[3].join(prokka_input.add)

  // User wants to call methylation?
  // If not (based on input.fofn) the process will only create blank files
  // so the pipeline doesn't stop
  call_methylation(methylation_input)

  // Grab inputs needed for JBrowse step
  jbrowse_input = update_gff.out[0].join(annotations_files, remainder: true)
                                   .join(call_methylation.out[2], remainder: true)
                                   .join(call_methylation.out[3], remainder: true)
                                   .join(call_methylation.out[4], remainder: true)
                                   .join(call_methylation.out[5], remainder: true)
                                   .join(call_methylation.out[6], remainder: true)
  // Jbrowse Creation
  jbrowse(jbrowse_input)

  // Render reports
  report(jbrowse_input.join(phigaro_output_txt, remainder: true))

}

/*
 * Define main workflow
 */

workflow {
  // Channel for execution
  input = Channel.empty()

  // Read genomes, line by line
  fofn   = file(params.genome_fofn)
  lines  = fofn.readLines()
  for( line in lines ) {

    // User do not want methylation call

    if (line.split(',').size() == 2) {
      (prefix, fasta) = line.split(',');
      input << [prefix, file(fasta)]
    }

    // User wants methylation call

    else if (line.split(',').size() == 4) {
      // Execute the workflow for each value pair
      (prefix, fasta, fastq_reads, fast5_dir) = line.split(',');
      input << [prefix, file(fasta), file(fastq_reads), file(fast5_dir)]
    }
  }

  // Run
  bacannot_nf(input)
}
